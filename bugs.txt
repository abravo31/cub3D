

For testing:
/******************************************/
If the texture doesn't exists, the pogram must finish properly
NO ./path_to_the_north_texture.xpm
SO    ./path_to_the_south_texture.xpm
WE       ./path_to_the_west_texture.xpm
EA                    ./path_to_the_east_texture.xpm

F 211, 151, 138                 100,255,255
C 99, 51, 40

11111
11001
 1211
1W001
 1011
  1


1. Control hooks with flag. 
2. Render according size of screen.
3. Map change dinamically with the hooks. 
4. Improve dda 
5. Loop for iterations in the hooks of doors (open/close)
   Rays must continue if doesn't hit door (double comparaison)!
6. Get distance and orientation_wall_hit

  static void	next_point_hit(t_cub3D *data, t_rc *rc, t_ray *ray, t_door *door, int dir)
{
	// ray->distance = ((door->initial_dda->x + 0.5) - rc->player.d_coords.x) / ray->ray_vector.x; 
	equation_straight_line(rc, ray, (door->initial_dda->x + 0.5), dir);
	printf("hit point x %f | y %f\n", ray->hit_point.x, ray->hit_point.y);
	
	// draw_square_point(data, ray->hit_point);
}

static void	get_next_hit(t_cub3D *data, t_ray *ray, t_door *door)
{
	printf("initial dda x %f | y %f\n", door->initial_dda->x, door->initial_dda->y);
	if (door->type_door == HORIZONTAL_DOOR)
	{
		printf("Debo buscar el siguiente punto en x\n");
	}
	else if (door->type_door == VERTICAL_DOOR)
	{
		// printf("Debo buscar el siguiente punto en y\n");
		if (ray->is_facing_rigth)
		{
			door->next_dda.x = door->initial_dda->x + 0.5;
		}
		else if (ray->is_facing_left)
		{
			// Esto no lo he testeado
			door->next_dda.x = door->initial_dda->x - 0.5;
		}
		next_point_hit(data, &data->rc, ray, door, HORIZONTAL);
		// if (ray->hit_point.x > (door->initial_dda->x + 0.5))
		// 	printf("Debe pegar en la puerta\n");
		// if (hit_point.y > (next_dda.y))
	}
}